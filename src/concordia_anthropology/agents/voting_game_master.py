from abc import ABC, abstractmethod
import re
from typing import TYPE_CHECKING, Any, Callable, Optional, Literal, Protocol, Final , Union,  cast, TypeVar, Type, Sequence
from typing_extensions import ParamSpec
from concordia.agents.entity_agent_with_logging import EntityAgentWithLogging
from concordia.components.game_master import make_observation
from concordia.typing.entity_component import ActingComponent, ComponentContextMapping, ComponentWithLogging, ComponentState, ContextComponent, EntityState
from concordia.typing.entity import ActionSpec, OutputType, DEFAULT_ACTION_SPEC
import functools
from dataclasses import dataclass, asdict
from concordia.environment.engines import sequential
from concordia.components.game_master.make_observation import DEFAULT_CALL_TO_MAKE_OBSERVATION
from concordia.environment.engine import action_spec_to_string
from concordia.components.game_master.event_resolution import PUTATIVE_EVENT_TAG, EVENT_TAG
from concordia_anthropology.utils.agent_string_parsing import split_tags_and_payload, parse_actor_and_content


# ---- Types

VoteStatus = Literal["up", "down"]
VoteOptionsDown = Literal["keep down", "raise"]
VoteOptionsUp = Literal["keep_raised", "lower"]


@dataclass
class VotingActionSpecOptions:
    down = ("keep down", "raise")
    up  = ("keep raised", "lower")
voting_action_spec_options = VotingActionSpecOptions()

Stage = Literal["present_proposal", "voting",  "observe_votes", "end_voting", "finished"]





# --- Utility ---


# Gets the initial dictionary of player's hands, with all hands down
def get_init_votes (players: list[str]) -> dict[str, VoteStatus]:
    hands : dict[str,VoteStatus] = {}
    for player in players:
        hands[player] = "down"
    return hands
T = TypeVar("T")

def head(seq: Sequence[T]) -> Optional[T]:
    return seq[0] if seq else None

# The ENUM OutputType in the Concordia libray has its fields defined with str type annotations and this breaks the type checking. So I've defined a function to get around it.

OutputTypeLiteral = Literal["free",
"choice",
"float",
"make_observation",
"next_acting",
"next_action_spec",
"resolve",
"terminate",
"next_game_master",
"skip_this_step",]

def outputType(type: OutputTypeLiteral) -> OutputType:
   return OutputType(type)

def action_spec_str(cta: str = "", choice_options: Optional[list[str]] = None) -> str:
    if not cta:
        return action_spec_to_string( ActionSpec(call_to_action="", output_type=outputType("skip_this_step")))
    elif not choice_options:
        return action_spec_to_string( ActionSpec(call_to_action=cta, output_type=outputType("free")))
    else:
        stripped_options = [o.strip() for o in choice_options]
        return action_spec_to_string(
        ActionSpec(call_to_action=cta, options=stripped_options, output_type=outputType("choice") )
    )


NO_ACTOR : Literal["NO_ACTOR"] = "NO_ACTOR"

# State
@dataclass
class VotingState:
    players: list[str]
    remaining_in_stage_to_act: list[str]
    remaining_in_stage_to_observe: list[str]
    current_votes: dict[str, VoteStatus]
    chair: str
    chair_title : str
    next_game_master: str


    # Default value fields
    prev_votes: Optional[dict[str, VoteStatus]] = None
    max_rounds: int = 5
    stage: Stage = "present_proposal"
    round_num: int = 1
    next_acting_pending_spec: Optional[str] = None # This is set when next_actor is given from the GM to engine. It is unset when the next next action spec is given.  When a player name is provided to the engine just to skip their action,  the value recorded here by set_next_acting is the  NO_ACTOR constant
    proposal_description : Optional[str] = None # This will be generated by the chair player entity and recorded here when the game master observes it.

    adopted : Optional[Literal["adopted", "not adopted"]] = None
    voting_result_description: Optional[str] = None

    def __init__(self,next_game_master: str,  players: list[str], chair: str, chair_title: str = "chairperson" ):
        de_duped = list(set(players))
        # The chair is the first in the list, the order of the other players doesn't matter.
        self.players = [chair] + [p for p in de_duped  if p != chair]
        self.current_votes = get_init_votes(self.players)
        self.next_game_master = next_game_master
        self.chair = chair
        self.chair_title = chair_title
        self.remaining_in_stage_to_act =  self.players.copy()
        self.remaining_in_stage_to_observe =  self.players.copy()

    def all_up(self, votes: dict[str, VoteStatus]):
        return all("up" == vote for vote in votes.values())

    def reset_remaining(self):
        # Resets action and observation trackers to initial state. Chair is at the head of the lists.
        self.remaining_in_stage_to_act = self.players.copy()
        self.remaining_in_stage_to_observe =  self.players.copy()

    # Deprecated / OLD TODO: remove after verifying
    # def end_observe_votes(self):
    #     """Ends the observe_votes stage. Sets stage to "voting", Ensures that prev_votes are set equal to current_votes and resets remaining_in_stage."""
    #     assert self.stage == "observe_votes"  and self.remaining_in_stage_to_act == []
    #     self.reset_remaining()
    #     self.prev_votes = {**self.current_votes}
    #     self.stage = "voting"

    def record_player_completion_for_stage(self, player:str, act_observe: Literal["act", "observe", "both"] = "both") -> None:
        assert player in self.players
        if act_observe == "act" or act_observe == "both":
            self.remaining_in_stage_to_act  =  [p for p in self.remaining_in_stage_to_act  if p != player]
        if act_observe == "observe" or act_observe == "both":
            self.remaining_in_stage_to_observe  =  [p for p in self.remaining_in_stage_to_observe  if p != player]


    def record_votes_observation(self, player: str) -> None:
        """This records when an observation has been make of the voting state by a player."""
        assert player in self.players
        assert self.stage == "observe_votes"
        self.record_player_completion_for_stage(player)


    def record_vote(self, player: str, vote: VoteStatus) -> None:
        """This records a vote by a player."""
        if player not in self.players or self.stage != "voting":
            raise ValueError()

        if player in self.remaining_in_stage_to_act:
            self.current_votes[player] = vote
            self.record_player_completion_for_stage(player)


    def next_player(self, act_observe: Literal["act", "observe"]) -> Optional[str]:
        if act_observe == "act":
            return head(self.remaining_in_stage_to_act)
        else:
            return head(self.remaining_in_stage_to_observe)



def entity_name_from_make_observation_CTA(cta: str) -> str:
    """
    Extracts the {name} from the default make_observation call to action used by the engine.
    Returns the name if found otherwise throws an error.
    Note: This could be fragile if Concordia is updated or when using a differnet concordia engine. It would be good in the future to pass the entity name directly, maybe as part of the action spec.
    """
    # Fast path for the exact default template
    prefix = "What is the current situation faced by "
    if cta.startswith(prefix):
        rest = cta[len(prefix):]
        q = rest.find("?")
        if q != -1:
            return rest[:q].strip()

    raise ValueError()



# Stages
StageAction = Literal["make_observation","next_acting","next_action_spec",]


class StageComponent():
    state: VotingState
    stage: Stage

    @abstractmethod
    def should_end_stage(self) -> Optional[Stage]: ...
    """Returns None if it is not time to end the stage, returns the name of the next stage if it is time."""


    def gm_observation(self, observation: str) -> None:
    # Use the default implementation for stages where the GM does not need to observe player actions.
        pass

    @abstractmethod
    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str: ...



    # ATTN: I'm not sure what the underlying ComponentWithLogging does with these so I'm just having
    def get_state(self) -> ComponentState:
        return {}
    def set_state(self, state: ComponentState) -> None:
        return None



    def resolve(self) -> None:
        """This resolves a stage and moves to the next stage. It should be called everytime the GM's acting component receives OutputType.Resolve"""
        state = self.state
        assert state.stage == self.stage
        next_stage = self.should_end_stage()

        if next_stage:
            # We go straight to "voting" and skip "observe votes" since nobody has had a chance to decide yet.
            state.stage = next_stage
            state.reset_remaining()

class PresentProposalStage(StageComponent, ComponentWithLogging):
    state: VotingState
    stage : Stage = "present_proposal"

    def __init__(self, state: VotingState):
        self.state = state

    def should_end_stage(self) ->Optional[Stage]:
        """If the chair has acted and all players have observed, we go to "voting"."""
        if self.state.remaining_in_stage_to_observe == [] and self.state.chair not in self.state.remaining_in_stage_to_act:
            return "voting"
    def gm_observation(self, observation: str) -> None:
        state = self.state
        tags, payload = split_tags_and_payload(observation)

        if PUTATIVE_EVENT_TAG not in tags: return

        actor, action_attempt = parse_actor_and_content(payload, [state.chair] )
        if actor != state.chair:
            raise ValueError(f"{actor} should be equal to {state.chair} as only the chair is acting this stage.")
        if not action_attempt:
            raise ValueError(f"Proposal description is empty.")
        state.proposal_description = action_attempt
        print(f"Saving proposal description as: {action_attempt}")

        # Update state to indicate that chair has acted this stage
        state.record_player_completion_for_stage(state.chair, 'act')

    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str:
        # The chair observes that it is time to make the proposal
        # The chair acts by making the proposal, and the GM must observe this an record the proposal description
        # Then all other players need to observe the proposal
        # No players other than the chair act in this stage.

        state = self.state
        match action_type:
            case "make_observation":
                observation_str : str
                player = entity_name_from_make_observation_CTA(call_to_action)
                if player not in state.players:
                    raise ValueError(f"The parsed player name '{player}' is not in the player list {state.players}")
                if player == state.chair and state.chair in state.remaining_in_stage_to_observe:
                    observation_str = """It is time now for you to present the proposal for voting."""
                    state.record_player_completion_for_stage(player, "observe")
                elif player in state.remaining_in_stage_to_observe and state.proposal_description:
                    observation_str = f"""{state.chair} reads out the proposal that you are being asked to vote on: \n {state.proposal_description}"""
                    state.record_player_completion_for_stage(player, "observe")
                else:
                    observation_str = ""
                return observation_str
            case "next_acting":
                if state.chair in state.remaining_in_stage_to_act and state.chair not in state.remaining_in_stage_to_observe:
                    # After the chair has observed and hasn't acted, then he acts.
                    return state.chair
                else:
                    # This will be handled by the acting component to generate a skip action spec.
                    return NO_ACTOR

            case "next_action_spec":
                if state.chair == state.next_acting_pending_spec:
                    return action_spec_str("Clearly state the proposed course of action that people are about to vote on. Only include the words you say with no other text.")

        return ""

def vote_change_str (prev: Literal['up', 'down'], current: Literal['up','down'], voter: str, player: str ):
        own_vote = player == voter
        possessive_subject = "Your" if own_vote else f"{voter}'s"

        res = ""
        match (prev, current):
            case ("up", "up"):
                res = f"{possessive_subject} hand is up and is voting to adopt the proposal"
            case ("down", "up"):
                res = "You raised a hand and are now voting to adopt the proposal" if own_vote else f"{voter} raised a hand and is now voting to adopt the proposal"
            case ("up", "down"):
                res = "You lowered your hand and are now voting not to adopt the proposal" if own_vote else f"{voter} lowered their hand and are now voting to not to adopt the proposal"
            case ("down", "down"):
                res = f"{possessive_subject} hand is down and is voting not to adopt the proposal"
        return res



class VotingStage (StageComponent, ComponentWithLogging):

    state: VotingState
    stage : Stage  = "voting"
    prev_votes_set: bool  = False


    def __init__(self, state: VotingState):
        self.state = state

    def should_end_stage(self) ->Optional[Stage]:
        state = self.state
        if state.remaining_in_stage_to_act:
            return None
        else:
            return "observe_votes"

    def gm_observation(self, observation: str) -> None:
        state = self.state
        if state.stage != "voting":
            return

        tags, payload = split_tags_and_payload(observation)
        if PUTATIVE_EVENT_TAG not in tags:
            return

        actor, attempt = parse_actor_and_content(payload, state.players)
        text = attempt.strip().lower()
        if actor not in state.players or not attempt:
            return

        vote = state.current_votes[actor] # Start with
        if "no change" in text or "do nothing" in text:
            pass
        elif "raise" in text:
            vote = "up"
        elif "lower" in text:
            vote = "down"
        else:
            pass
        state.record_vote(actor, vote) # record_vote also records player completion for the stage


    def set_prev_votes(self):
        state = self.state
        if not self.prev_votes_set:
            self.prev_votes_set = True # This applies to the current round of voting
            if state.round_num > 1:
                # If it is not the initial round of voting we set the prev_votes to store the previous results. This will be used by ObserveVotingStage.
                state.prev_votes = state.current_votes.copy()


    def resolve(self):
        """If the resolve changes the round, reset the prev_vote_set variable to false and set the initial_round to False."""
        state = self.state
        super().resolve()
        if state.stage != self.stage:
            self.prev_votes_set = False


    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str:
        self.set_prev_votes()
        state = self.state
        match action_type:
            case "make_observation":
                return ""
            case "next_acting":
                next_actor =  state.next_player('act')
                if next_actor:
                    return next_actor
                else:
                    return NO_ACTOR
            case "next_action_spec":
                if state.next_acting_pending_spec not in state.players:
                    raise ValueError(f"Something went wrong if this is called with {state.next_acting_pending_spec}")
                player : str  = state.next_acting_pending_spec
                hand_status : Literal['up', 'down'] = state.current_votes[player]

                cta: str
                options: list[str]
                if state.round_num == 1: # First round of voting
                    cta = "You are just starting to vote on whether to adopt the proposal. You can raise your hand to vote to adopt the proposal or do nothing."
                    options = ["raise hand", "do nothing"]
                else:
                    cta = f"You are in the middle of voting on whether to adopt the proposal. Currently your hand is {hand_status} which means that until now you decided {"to vote" if hand_status == "up" else "not to vote"} to adopt the proposal. You are free to change your mind."
                    if hand_status == "up":
                        options = ["no change", "lower hand"]
                    else:
                        options = ["no change", "raise hand"]
                return action_spec_str( cta, options) # choice action spec string


class ObserveVotesStage (StageComponent, ComponentWithLogging):
    """This is the stage where all players observe the votes of everyone. No players act this stage so the GM doesn't observe anything."""
    state: VotingState
    stage : Stage   = "observe_votes"

    def __init__(self, state: VotingState):
        self.state = state


    def should_end_stage(self) ->Optional[Stage]:
        """Performs checks and bookkeeping"""
        state = self.state
        if state.remaining_in_stage_to_act != []:
            return None
        if state.prev_votes and state.all_up(state.prev_votes) and state.all_up(state.current_votes):
        # If all votes are up for this round and previous round, voting is ended and proposal is adopted.
            state.adopted = "adopted"
            return  "end_voting"

        elif state.round_num < state.max_rounds:
            # We reset and go to next round
            state.round_num = state.round_num + 1
            return "observe_votes"

        else: # Last round, move to end voting
            if state.all_up(state.current_votes):
                state.adopted = "adopted"
            else:
                state.adopted = "not adopted"
            return "end_voting"


    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str:
        state = self.state
        match action_type:
            case "make_observation":
                player = entity_name_from_make_observation_CTA(call_to_action)
                if player not in state.players:
                    raise ValueError(f"The parsed observer {player} is not in {state.players}")
                # Players don't act in this stage so we record completion for both obsevering and acting
                state.record_player_completion_for_stage(player, "both")
                return self.get_votes_observation(player)
            case "next_acting":
                # Nobody takes an action in this stage
                return NO_ACTOR
            case "next_action_spec":
                # This should never be reached since NO_ACTOR is caught in the acting component
                raise ValueError("next_action_spec action type should not be seen in ObserveVotesStage component.")

    def get_votes_observation(self, player: str) -> str:
        state = self.state
        current_votes = state.current_votes
        prev_votes = state.prev_votes
        observation_str = "You look around and see how everybody voted:\n"

        for voter, vote in current_votes.items():
            if prev_votes and voter in prev_votes:
                observation_str += vote_change_str(prev_votes[voter], vote, voter, player) + "\n"
            else:
                # If there are no previous votes, we assume that all hands start down.
                observation_str += vote_change_str("down", vote, voter, player) + "\n"
        return observation_str



class EndVotingStage (StageComponent, ComponentWithLogging):
    state: VotingState
    stage: Stage = "end_voting"
    def __init__(self, state: VotingState):
       self.state = state

    def should_end_stage(self) ->Optional[Stage]:
        state = self.state
        if state.remaining_in_stage_to_observe:
            return None
        else:
            return "finished"

    def gm_observation(self, observation: str) -> None:
        state = self.state
        if state.stage != "end_voting":
            return

        tags, payload = split_tags_and_payload(observation)
        if PUTATIVE_EVENT_TAG not in tags:
            return

        actor, text = parse_actor_and_content(payload, state.players)

        if actor != state.chair or not text:
            raise ValueError(f"GM observation error, with actor {actor} and attempt string {text}")

        state.voting_result_description = text

    def get_voting_result_str(self) -> str:
        adopted_status :Literal['adopted', 'not adopted'] | None = self.state.adopted
        if adopted_status == "adopted":
            return f"By unanimous vote the participants have decided to adopt the policy."
        elif adopted_status == "not adopted":
            return "Since some participants did not vote for the policy, the policy will not be adopted. It may be discussed and re-voted on in a future meeting."
        else:
            raise ValueError("The adopted status is invalid")


    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str:
        state = self.state


        match action_type:
            case "make_observation":
                if state.voting_result_description == None:
                    # Note: the voting result description is set after the chair's action is observed by the GM.
                    return ""
                player = entity_name_from_make_observation_CTA(call_to_action)
                if player not in state.players:
                    raise ValueError(f"The parsed observer {player} is not in {state.players}")

                obs_str: str = self.get_voting_result_str() + f"\nThe {state.chair_title} speaks to conclude the voting: {state.voting_result_description}"

                state.record_player_completion_for_stage(player, "observe")
                return obs_str
            case "next_acting":
                if state.chair in state.remaining_in_stage_to_act:
                    return state.chair
                else:
                    return  NO_ACTOR
            case "next_action_spec":
                if state.chair == state.next_acting_pending_spec:
                    cta = f"{self.get_voting_result_str()} it is now time for you to speak to the people here and describe the result of the voting. Only include the words you say with no other text."
                    return action_spec_str(cta) # Free action spec string
                else:
                    raise ValueError(f"next_action_spec action type should not be seen for the {state.next_acting_pending_spec} in EndVotingStage.")

# Note: we don't have a stage component for finish voting since this stage is just to hand off to the next game master.


# Acting Component
class VotingActingComponent(ActingComponent, ComponentWithLogging):

    def __init__(self,  next_game_master: str,  state: VotingState, stage_components: dict[Stage, StageComponent]  ):
        self.state = state
        self.next_game_master = next_game_master
        self.stage_components = stage_components

    def get_state(self) -> ComponentState:
        return  cast(ComponentState, asdict(self.state))

    # Not implemented.
    def set_state(self,state: ComponentState) -> None :
        pass



    def get_action_attempt(
      self,
      context: ComponentContextMapping,
      action_spec: ActionSpec,
    ) -> str:
        state = self.state
        stage_component = self.stage_components[state.stage]
        if not stage_component:
            raise ValueError(f"Stage component for {state.stage} in get_action_attempt is not defined.")

        call_to_action = action_spec.call_to_action
        action_attempt_string = ""
        match action_spec.output_type:
            case OutputType.RESOLVE:
                stage_component.resolve()
                # Note: We return an empty string from resolve because the game master captures any info it needs into its state from observation of the Putative Event (player's action attempt) which happens just before the resolve call.
            case OutputType.NEXT_GAME_MASTER:
                if state.stage == "finished":
                    return state.next_game_master
                else:
                    return VOTING_GM_NAME
            case OutputType.MAKE_OBSERVATION:
                action_attempt_string = stage_component.get_action_string("make_observation",call_to_action)
            case OutputType.NEXT_ACTING:
                next_actor = stage_component.get_action_string("next_acting",call_to_action)
                if next_actor in action_spec.options:
                    action_attempt_string = next_actor
                elif next_actor != NO_ACTOR:
                    raise ValueError(f"In VotingActingComponent, next_acting action attempt was {next_actor} which is not a valid entity in {action_spec.options}")
                else:
                    action_attempt_string = state.chair # We default to the chair as our dummy action when we will skip the action.

                # This informs components of the pending actor (or NO_ACTOR) for generating the correct action spec.
                self.state.next_acting_pending_spec = next_actor

            case OutputType.NEXT_ACTION_SPEC:
                action_attempt_string : str
                if state.next_acting_pending_spec == NO_ACTOR or not self.state.next_acting_pending_spec:
                    action_attempt_string = action_spec_str()  # Defaults to skip with no arguments
                else:
                    action_attempt_string = stage_component.get_action_string("next_action_spec",call_to_action)
                state.next_acting_pending_spec = None
            case OutputType.TERMINATE:
                return "No"
            #The voting game master will never terminate the simulation.
            # We could change this so it terminates in phrase finished if there is no next_game_master.
            # For now I assume there will always be a handoff to another game master to finish the simualation.
            case _:
                raise NotImplementedError(f"Unsupported output type: {action_spec.output_type}")


        return action_attempt_string

VOTING_GM_NAME : Literal["VOTING_GM"] = "VOTING_GM"

class VotingGameMaster (EntityAgentWithLogging):
    state : VotingState
    stage_components : dict[Stage, StageComponent]
    acting_component : VotingActingComponent
    def __init__(self, next_game_master: str, players: list[str], chair: str, chair_title: str = "chairperson" ):
        self.state = VotingState(next_game_master, players, chair, chair_title)

        self.stage_components : dict[Stage, StageComponent]  = {
            "present_proposal": PresentProposalStage(self.state),
            "observe_votes": ObserveVotesStage(self.state),
            "voting": VotingStage(self.state),
            "end_voting": EndVotingStage(self.state),
            "finished": StageComponent() # This is dummy component which won't be used.
        }

        self.acting_component =  VotingActingComponent(next_game_master, self.state, self.stage_components)

        super().__init__(VOTING_GM_NAME, self.acting_component)

    @functools.cached_property
    def name(self) -> str:
        return VOTING_GM_NAME

    def observe(self, observation: str) -> None:
        state = self.state

        # These are the stages where the GM needs to make an observation of player actions
        gm_observation_stages :list[Stage] = ["present_proposal", "voting"]
        if state.stage in gm_observation_stages:
            stage_component = self.stage_components[state.stage]
            if not stage_component:
                raise ValueError(f"No stage component for {state.stage}")

            # The stage component handles updates to the GM's states based on the GM's own obersvations.
            stage_component.gm_observation(observation)




    def act(self, action_spec: ActionSpec = DEFAULT_ACTION_SPEC) -> str:
        return self.acting_component.get_action_attempt({}, action_spec)








