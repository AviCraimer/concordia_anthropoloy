from abc import ABC, abstractmethod
import re
from typing import TYPE_CHECKING, Any, Callable, Optional, Literal, Protocol, ReadOnly, Union,  cast, TypeVar, Type, Sequence
from typing_extensions import ParamSpec
from concordia.agents.entity_agent_with_logging import EntityAgentWithLogging
from concordia.components.game_master import make_observation
from concordia.typing.entity_component import ActingComponent, ComponentContextMapping, ComponentWithLogging, ComponentState, ContextComponent
from concordia.typing.entity import ActionSpec, OutputType

from dataclasses import dataclass, asdict
from concordia.environment.engines import sequential
from concordia.components.game_master.make_observation import DEFAULT_CALL_TO_MAKE_OBSERVATION


# ---- Types

VoteStatus = Literal["up", "down"]
VoteOptionsDown = Literal["keep down", "raise"]
VoteOptionsUp = Literal["keep_raised", "lower"]


@dataclass
class VotingActionSpecOptions:
    down = ("keep down", "raise")
    up  = ("keep raised", "lower")
voting_action_spec_options = VotingActionSpecOptions()

Stage = Literal["present_proposal", "observe_votes", "voting", "finished"]
stages = ("present_proposal", "observe_votes", "voting", "finished")



# --- Utility ---
# Gets the initial dictionary of player's hands, with all hands down
def get_init_votes (players: list[str]) -> dict[str, VoteStatus]:
    hands : dict[str,VoteStatus] = {}
    for player in players:
        hands[player] = "down"
    return hands
T = TypeVar("T")

def head(seq: Sequence[T]) -> Optional[T]:
    return seq[0] if seq else None

# The ENUM OutputType in the Concordia libray has its fields defined with str type annotations and this breaks the type checking. So I've defined a function to get around it.

OutputTypeLiteral = Literal["free",
"choice",
"float",
"make_observation",
"next_acting",
"next_action_spec",
"resolve",
"terminate",
"next_game_master",
"skip_this_step",]

def outputType(type: OutputTypeLiteral) -> OutputType:
   return OutputType(type)


cast(OutputType, OutputType.FREE)


# State
@dataclass
class VotingState:
    players: list[str]
    remaining_in_stage_to_act: list[str]
    remaining_in_stage_to_observe: list[str]
    current_votes: dict[str, VoteStatus]
    chair: str

    # Default value fields
    prev_votes: Optional[dict[str, VoteStatus]] = None
    max_rounds: int = 5
    stage: Stage = "present_proposal"
    round_num: int = 1
    proposal_description : str = "" # This will be generated by the chair player entity and recorded here when the game master observes it.


    adopted : Optional[Literal["adopted", "not adopted"]] = None

    def __init__(self, players: list[str], chair: str, chair_title: str = "chairperson"):
        de_duped = list(set(players))
        # The chair is the first in the list, the order of the other players doesn't matter.
        self.players = [chair] + [p for p in de_duped  if p != chair]
        self.current_votes = get_init_votes(players)

        self.chair = chair
        self.chair_title = chair_title
        self.remaining_in_stage_to_act =  players.copy()
        self.remaining_in_stage_to_observe =  players.copy()


    def all_up(self, votes: dict[str, VoteStatus]):
        return all("up" == vote for vote in votes.values())

    def reset_remaining(self):
        # Resets action and observation trackers to initial state. Chair is at the head of the lists.
        self.remaining_in_stage_to_act = self.players.copy()
        self.remaining_in_stage_to_observe =  self.players.copy()




    def end_observe_votes(self):
        """Ends the observe_votes stage. Sets stage to "voting", Ensures that prev_votes are set equal to current_votes and resets remaining_in_stage."""
        assert self.stage == "observe_votes"  and self.remaining_in_stage_to_act == []
        self.reset_remaining()
        self.prev_votes = {**self.current_votes}
        self.stage = "voting"



    def record_player_completion_for_stage(self, player:str, act_observe: Literal["act", "observe", "both"] = "both") -> None:
        assert player in self.players
        if act_observe == "act" or act_observe == "both":
            self.remaining_in_stage_to_act  =  [p for p in self.remaining_in_stage_to_act  if p != player]
        if act_observe == "observe" or act_observe == "both":
            self.remaining_in_stage_to_observe  =  [p for p in self.remaining_in_stage_to_act  if p != player]


    def record_votes_observation(self, player: str) -> None:
        """This records when an observation has been make of the voting state by a player."""
        assert player in self.players
        assert self.stage == "observe_votes"
        self.record_player_completion_for_stage(player)


    def record_vote(self, player: str, vote: VoteStatus) -> None:
        """This records a vote by a player."""
        assert player in self.players
        assert self.stage == "voting"

        if player in self.remaining_in_stage_to_act:
            self.current_votes[player] = vote
            self.record_player_completion_for_stage(player)

    def next_player(self, act_observe: Literal["act", "observe"]) -> Optional[str]:
        if act_observe == "act":
            head(self.remaining_in_stage_to_act)
        else:
            head(self.remaining_in_stage_to_observe)



def entity_name_from_make_observation_CTA(call: str) -> str:
    """
    Extracts the {name} from the default make_observation call to action used by the engine.
    Returns the name if found otherwise throws an error.
    """
    # Fast path for the exact default template
    prefix = "What is the current situation faced by "
    if call.startswith(prefix):
        rest = call[len(prefix):]
        q = rest.find("?")
        if q != -1:
            return rest[:q].strip()

    raise ValueError()


StageAction = Literal["make_observation","next_acting","next_action_spec",]

class StageComponent():
    state: VotingState
    stage: Stage

    @abstractmethod
    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str: ...

    @abstractmethod
    def should_end_stage(self) -> Optional[Stage]: ...
    """Returns None if it is not time to end the stage, returns the name of the next stage if it is time."""

    def resolve(self) -> None:
        """This resolves a stage and moves to the next stage. It should be called everytime the GM's acting component receives OutputType.Resolve"""
        state = self.state
        assert state.stage == self.stage
        next_stage = self.should_end_stage()

        if next_stage:
            # We go straight to "voting" and skip "observe votes" since nobody has had a chance to decide yet.
            state.stage = next_stage
            state.reset_remaining()

class PresentProposalStage(ComponentWithLogging, StageComponent):
    state: VotingState
    stage : ReadOnly[Stage] = "present_proposal"

    def __init__(self, state: VotingState):
        self.state = state

    def should_end_stage(self) ->Optional[Stage]:
        """If the chair has acted and all players have observed, we go straight to "voting" and skip "observe votes" since nobody has had a chance to vote yet."""
        if self.state.remaining_in_stage_to_observe == [] and self.state.chair not in self.state.remaining_in_stage_to_act:
            return "voting"

    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str:
        # The chair observes that it is time to make the proposal
        # The chair acts by making the proposal, and the GM must observe this an record the proposal description
        # Then all other players need to observe the proposal
        # No players other than the chair act in this stage.

        state = self.state
        match action_type:
            case "make_observation":
                observation_str : str
                player = entity_name_from_make_observation_CTA(call_to_action)
                if player == state.chair and state.chair in state.remaining_in_stage_to_observe:
                    observation_str = """It is time now for you to present the proposal for voting. Please clearly state the proposed course of action for everybody to listen."""
                    state.record_player_completion_for_stage(player, "observe")
                elif player in state.remaining_in_stage_to_observe and state.proposal_description != "":
                    observation_str = f"""{state.chair} reads out the proposal that you are being asked to vote on: \n {state.proposal_description}"""
                    state.record_player_completion_for_stage(player, "observe")
                else:
                    observation_str = ""
                return observation_str
            case "next_acting":
                if state.chair in state.remaining_in_stage_to_act and state.chair not in state.remaining_in_stage_to_observe:
                    # After the chair has observed and hasn't acted, then he acts.
                    return state.chair
                else:
                    # No one else other than the chair should act, so I'm not sure what to put here.
                    return ""

            case "next_action_spec":
                # TODO - What kind of string do I need to return for an action spec?
                pass
        return ""



class ObserveVotesStage (ComponentWithLogging, StageComponent):
    state: VotingState
    stage : ReadOnly[Stage]   = "observe_votes"

    def __init__(self, state: VotingState):
        self.state = state

    def should_end_stage(self) ->Optional[Stage]:
        """Performs checks and bookkeeping"""
        state = self.state
        if state.remaining_in_stage_to_act != []:
            return None
        if state.prev_votes and state.all_up(state.prev_votes) and state.all_up(state.current_votes):
        # If all votes are up for this round and previous round, voting is finished and proposal is adopted.
            state.adopted = "adopted"
            return  "finished"

        elif state.round_num < state.max_rounds:
            # We reset and go to next round
            state.round_num = state.round_num + 1
            return "observe_votes"

        else: # Last round, move to finished
            if state.all_up(state.current_votes):
                state.adopted = "adopted"
            else:
                state.adopted = "not adopted"
            return "finished"


    def get_votes_observation(self, player: str) -> str:
        state = self.state
        assert player in state.players
        # TODO: Implement the get_votes_observation_method
        return ""

    def get_action_string(self, action_type: StageAction, call_to_action: str) -> str:
        state = self.state
        match action_type:
            case "make_observation":
                player = entity_name_from_make_observation_CTA(call_to_action)
                # Players don't act in this stage so we record completion for both obsevering and acting
                state.record_player_completion_for_stage(player, "both")
                return self.get_votes_observation(player)
            case "next_acting":
                    return "" # No one acts
            case "next_action_spec":
                return "" # No one acts




class Voting (ComponentWithLogging, StageComponent):
    state: VotingState
    stage : ReadOnly[Stage]  = "voting"

    def __init__(self, state: VotingState):
        self.state = state

    def get_action_string(self, action_spec: ActionSpec):
        return ""

class FinishedVoting (ComponentWithLogging, StageComponent):
    state: VotingState
    stage: Stage = "finished"
    def __init__(self, state: VotingState):
       self.state = state



# Acting Component
class VotingActingComponent(ActingComponent, ComponentWithLogging):

    def _init_(self,  next_game_master: str,  state: VotingState, stage_components: dict[Stage, StageComponent]  ):
        self.state = state
        self.next_game_master = next_game_master
        self.stage_components = stage_components

    def get_state(self) -> ComponentState:
        return  cast(ComponentState, asdict(self.state))

    # Not implemented.
    def set_state(self,state: ComponentState) -> None :
        pass



    def get_action_attempt(
      self,
      context: ComponentContextMapping,
      action_spec: ActionSpec,
    ) -> str:
        state = self.state
        stage_component = self.stage_components[state.stage]
        assert stage_component != None
        call_to_action = action_spec.call_to_action
        action_attempt_string = ""
        match action_spec.output_type:
            case OutputType.RESOLVE:
                stage_component.resolve()
            case OutputType.NEXT_GAME_MASTER:
                pass # TODO
            case OutputType.MAKE_OBSERVATION:
                action_attempt_string = stage_component.get_action_string("make_observation",call_to_action)
            case OutputType.NEXT_ACTING:
                action_attempt_string = stage_component.get_action_string("next_acting",call_to_action)
            case OutputType.NEXT_ACTION_SPEC:
                action_attempt_string = stage_component.get_action_string("next_action_spec",call_to_action)
            case _:
                action_attempt_string = ""

        return action_attempt_string





def voting_game_master(next_game_master: str, players: list[str], chair: str, chair_title: str = "chairperson"  ):
    components: dict[str, ContextComponent] = {}

    return EntityAgentWithLogging(
        agent_name="voting_game_master",
        act_component=VotingActingComponent(next_game_master, players, chair, chair_title ),
        context_components=components,
    )



